# 5장. 함수

## 함수 선언과 호출

p132. "같은 타입의 여러 입력 파라미터를 가지는  함수를 작성할 때 입력 파라미터를 다음과 같이 작성할 수 있다."
```go
func div(n, d int) int {
	if d == 0 {
        return 0
    }
	retrun n / d
}
```

p133. "함수를 위한 파라미터는 호출 시 모두 넘겨져야 한다. 이름이 지정된 파라미터나 선택적 파라미터처럼 사용하고 싶다면, 파라미터로 사용될 것과 동일하게 구조체로 만들어 함수로 넘겨줘야 한다."
p134. 가변 인자와 함께 슬라이스 사용하는 방법

```go
func addTo(b int, values ...int) [] int {
	// ...
}

func main(){
   a := []int { 4, 5 }
   addTo(3, a...)
}
```

p139. "이름이 지정된 반환 파라미터는 반환 값을 담기 위한 변수를 사용하는 것처럼 선언하는 방법을 제공한 것이 굳이 그것을 사용할 필요는 없다." -> 왜 이런걸 만들어서 더 헷갈리는걸 야기하는지...

p140. "경험 많은 Go 개발자들은 데이터 흐름을 이해하기 어려워지게 만들기 때문에 빈 반환은 좋은 생각이 아니라고 판단한다.", "함수가 값을 반환한다면 빈 반환은 절대 사용하지 말자. 실제 어떤 값이 반환되는지 알아내기 어려울 수 있다." -> 문법 자체는 신기하나 무쓸모.. 왜 만든거야? v2"


## 함수는 값이다

인상 깊은 구절이 없다.

## 클로저

p147. "놀랍게도 클로저는 아주 유용하다는 것으로 밝혀졌다. ... 클로저 반환에 관해서는 서버 중 미들웨어에서 웹서버를 위한 미들웨어를 만들 때 사용된 패턴을 볼 수 있을 것이다."

## defer

try-resource 구문처럼 함수 시작 구문에 리소스 해제를 할 수 있는 구문이라 흥미로웠다. 실제로 DB 커넥션 등 리소스 해제 때 사용하게 된다.

p149. "defer는 Go 함수에서 여러 클로저를 지연시킬 수 있다. 후입선출의 순서로 실행된다. 마지막 defer로 등록된 것이 가장 먼저 실행된다."

## 값에 의한 호출을 사용하는 Go

p155. "Go의 모든 타입은 값 타입이다. 때론 값이 포인터일 뿐이다."