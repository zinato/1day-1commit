# 7장 타입, 메서드, 인터페이스

## Go의 타입

p181. "Go는 소프트웨어 엔지니어가 권장하는 모범 사례를 사용하도록 하고 컴포지션을 권장하면서 상속을 피하도록 설계되었다." - 엔지니어가 번역한게 맞을까..?

## 메서드 

p183. "함수와 같이 메서드 이름은 오버로드 되지 않는다. 다른 타입을 위한 같은 이름의 메서드는 사용할 수 있지만 같은 타입의 다른 메서드를 동일한 이름으로 사용할 수 없다. ... 이름을 재사용하지 않는 것은 코드가 수행하는 작업을 명확히 하는 Go 철학의 일부이다."

p183. "포인터 리시버 타입 사용 규칙."

p186. "인터페이스를 충족시키는데 필요한 경우가 아니라면 Go 구조체에 대한 getter와 setter 메서드는 작성하지 않는다는 것을 기억하자. Go는 각 항목에 직접 접근하는 것을 권장한다." 

p186. "Go는 조금 다르게 수행한다. 실제 메서드를 수행하려고 시도한다."

p187. "Contains 메서드는 값을 수정하지 않지만 포인터 리시버를 선언한다. 이것은 nil 리시버를 지원하는 것에 대한 이전에 언급한 규칙을 확인시켜준다."

p188. "Go에서 nil 리시버에서 메서드를 호출할 수 있다는 것은 매우 영리한 방식이며 트리 노드 예제와 같이 유용하게 사용할 수 있다. 하지만 대부분의 경우 그다지 유용하지 않다."

p189. "메서드 표현의 경우에 함수 시그니처 func(Adder, int) int 에서 첫 번쨰 파라미터는 메서드를 위한 리시버이다."

p189. "함수와 메서드를 구분하는 요소는 함수가 다른 데이터에 의존적인지 여부이다. ... 당신의 로직이 시작할 때 설정되거나 프로그램이 수행하는 중에 변경되는 값에 의존할 때마다 해당 값은 구조체에 저장되어야 하면 로직은 메서드로 구현되어야 한다. 로직이 단지 입력 파라미터에 의존적이라면 함수로 구현하면 된다." -> 와우 번역.... 

p191. "타입은 문서라는 것이다."

p192. "iota에 관련된 최고의 조언이 있다."

## 컴포지션을 위한 임베딩 사용

## 임베딩은 상속이 아니다

## 인터페이스에 대한 간단한 지도

## 인터페이스는 타입데 안정적인 덕 타이핑이다

## 임베딩과 인터페이스

## 인터페이스를 받고 구조체 반환하기

## 인터페이스와 nil

## 빈 인터페이스는 어떤 것도 표현하지 않는다

## 타입 어썰션 및 타입 스위치

## 타입 어썰션과 타입 스위치를 아껴 사용하기

## 함수 타입은 인터페이스로의 연결

## 의존성 주입을 쉽게 만드는 암묵적 인터페이스

## Wire

## Go는 특히 객체 지향이 아니다