# 08장 에러

## 에러 처리 방법: 기초

p223. "관용적 Go는 코드 라인이 더 많이 생성되더라도 명확한 코드를 선호한다."

## 단순 에러에 문자열 사용

errors.New, fmt.Errorf 로 문자열 형태로 에러 문구를 반환한다.

## 센티넬 에러

p224. "단지 오류만 확인할 것이 아니라 오류를 멋지게 처리도 해야 한다."
p225. "하지만 더 이상 처리가 가능하지 않고 오류 상태를 설명하는 문맥적 정보를 더 이상 사용할 필요가 없는 특정 상태에 도달했음을 나타내는 오류 조건이 있다면 센티넬 에러로 처리하는 것이 올바른 선택이다."
p227. "Go는 언어를 단순하게 유지하고 기능을 추가하는 것보다 개발자와 도구의 신뢰를 높이는 게 더 좋다는 철학이 있다."

## 에러는 값이다
 
인상 깊은 구절이 없다.

## 에러 래핑

p230. "추가 정보를 추가하면서 에러를 유지하는 것을 wrapping error, 일련의 래핑된 에러를 가질 때 그것을 error chain 이라 부른다."

## Is와 AS

p236. "As 메서드를 구현하는 것은 사소하지 않고 리플렉션이 요구된다. 이는 하나의 에러 타입을 일치시키고 다른 타이븡ㄹ 반환하느 경우와  같은 특수한 상황에서만 사용하도록 하자."

## defer로 에러 래핑

## panic과 recover

p239. "recover를 사용하는 특정한 패턴이 있다. 잠재적인 panic을 처리하기 위한 defer 함수를 등록한다. if 문 내에서 recover를 호출하고 nil 아닌 값인지 확인한다. 일단 패닉이 발생하면 defer로 등록된 함수만 실행할 수 있기 때문에 recover는 반드시 defer 내에 호출해야 한다.".
p240. "치명적 상황에 대한 panic을 예약하고 안정적으로 이런 상황을 처리할 수 있는 방법으로 recover를 사용하자."
-> 서드 파티를 위한 라이브러리를 생성할 때 recover 사용 추천

## 에러에서 스택 트레이스 얻기

p241. "새로운 Go 개발자가 panic과 recover에 대한 유혹을 받는 이유 중 하나는 문제가 발생했을 때 스택 트레이스를 얻기 때문이다." -> 안다면 표준 라이브러리에 이썽ㅆ어야 하지 않을까..
