# 11장 표준 라이브러리

p313. "파이썬처럼 Go도 응용 프로그램을 만들 때 필요한 많은 도구를 제공하는 '건전지 포함' 철핡을 가진다는 것이다."

## 입출력 관련 기능

p316. "7.6절 '인터페이스는 타입에 안정적인 덕 타이핑이다.'에서 논의된 바와 같이 io.Reader와 io.Writer의 구현은 종종 데코레이터 패터으로 함께 연경된다." 

> [아래 예제가 데코레이터 패턴인가?](https://refactoring.guru/design-patterns/decorator/go/example)
>
> Decorator는 Decorator라고 하는 특수 래퍼 객체 내부에 배치하여 객체에 새로운 동작을 동적으로 추가할 수 있는 구조적 패턴(Structural pattern)입니다.

p318. "이것은 사용자 지정 타입을 사용하여 더 명확하게 운영이 되었어여 했지만 설계 감시 소홀로 whence는 타입이 int가 되었다."

## 시간

p320. "Go는 일반적으로 과거에 잘 동작했던 아이디어를 체택했지만, 자체적으로 날짜 및 시간 포매팅 언어를 사용한다." -> 직관적이지가 않다. 실제로 코드를 쳐봐도 왜 이런 결과가 나오는지 이해하기 어렵다.

p322. "기본 time.Ticker는 중단할 수 없기 때문에 사소한 프로그램의 외부에 time.Tick을 사용하지 말자. 대신에 채널을 기다릴 뿐만 아니라 Ticker를 리셋하거나 중지할 수 있는 메서드를 가지는 *time.Ticker를 반환하는 time.NewTicker를 사용하자." -> Go concurrency 패턴 중에 사용 사례가 있다. Go In Action

## encoding/json

p323. "마샬링이라는 단어는 Go 데이터 타입을 인코딩으로 변환하는 것을 의미하고 언마샬링은 Go 데이터 타입으로 변환하는 것을 의미한다." -> 다른 언어에서도 그러지 않나...?

p324. "구조체 태그는 하나 이상의 태그/값 쌍으로 구성되어 태그이름:"태그 값"으로 쓰고 공백으로 구분한다. 이것도 단순한 문자열이기 때문에 컴파일러는 해당 포맷이 정상적인지 검증할 수 없지만, go vet은 할 수 있다."

p325. 11.3.4 음 쌈빡하긴 한데 리플렉션을 이용한다면, 결국 애노테이션 사용하는거랑 뭐가 차이가 있는걸까?

p330. "JSON을 JSON을 위한 타입으로 읽어드려 다른 타입을 복사한다 ... 이것은 약간의 중복을 생성하지만 와이어 프로토콜에 의존하지 않고 비지니스 로직을 유지하게 해준다."

## net/http

* 장 전체적으로 node의 express 혹은 python의 flask 프레임워크를 사용해본 경험이 있어서인지 친숙한 코드들이 나와서 반가웠다. 이게 표준 라이브러리로 제공한다는게 신기했다. 
