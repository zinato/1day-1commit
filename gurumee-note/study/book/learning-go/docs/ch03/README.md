# 3장 복합 타입

## 배열

p66 "희소 배열(대부분의 요소의 값이 0으로 설정된 배열)을 만든다면 배열 리터럴 내에 지정된 인덱스와 값만 설정할 수 있다."
배열을 아래처럼 선언할 수 있다는게 신기했다. 현재부터 다음 인덱스까지 0으로 초기화된다.

```go
x := [12]int{1, 5: 4, 6, 10: 100, 15}
fmt.Println(x) // [1 0 0 0 0 4 6 0 0 0 100 15]
```

p67. "예를 들면, 배열을 [3]int로 선언한 것은 [4]int와 다른 타입으로 만든다.", "동일한 타입을 가진 다른 크기의 배열 간에 타입 변환을 시도할 수 없다." 
왜 제약을 만들었을까?

## 슬라이스

p70. "하나의 슬라이스에 다른 슬라이스의 개별 요소들을 ... 연산자를 이용해 추가하여 확장할 수 있다."
```go
x1 := make([]int)
x2 := []int{1, 2, 3}

x1 = append(x1, x2...)
fmt.Println(x1) // [1, 2, 3]
```

p76. "개인적으로 0의 길이로 슬라이스를 초기화하고 append를 사용하기를 권장한다. 어떤 경우에는 느려질 수 있겠지만, 코드의 버그를 줄일 수 있다."

p79. "복잡한 슬라이스 상황이 발생하지 않도록 하기 위해 하위 슬라이스에 append를 하지 사용하지 않거나 append를 사용해도 덮어쓰기가 되지 않도록 하는 완전한 슬라이스 연산을 사용하도록 하자."

```go
// x2 = [10 20 30 40 0 0 0 0 0 1 20 30 40],
y := x2[2:5]   // 30, 40, 0
z := x2[2:5:5] // 30, 40, 0
fmt.Printf("x2: %v, y: %v, z: %v\n", x2, y, z)

y[1] = 5    // x2 = [10 20 30 5 0 0 0 0 0 1 20 30 40] y = [30 5 0] z = [30 5 0] 
z[1] = 6    // x2 = [10 20 30 6 0 0 0 0 0 1 20 30 40] y = [30 6 0]  z = [30 6 0] 
fmt.Printf("x2: %v, y: %v, z: %v\n", x2, y, z)

y = append(y, 69)   // x2 = [10 20 30 6 0 69 0 0 0 1 20 30 40] y = [30 6 0 69] z = [30 6 0] 
z = append(z, 699)  // x2 = [10 20 30 6 0 69 0 0 0 1 20 30 40] y = [30 6 0 69] z = [30 6 0 699] 
fmt.Printf("x2: %v, y: %v, z: %v\n", x2, y, z)
// "full slice expression"으로 append 되면 그 때부터 다른 슬라이스가 된다.
y[2] = 5 // x2 = [10 20 30 6 5 69 0 0 0 1 20 30 40] y = [30 6 5 69] z = [30 6 0 699]  
z[2] = 6 // x2 = [10 20 30 6 5 69 0 0 0 1 20 30 40] y = [30 6 5 69] z = [30 6 6 699] 
fmt.Printf("x2: %v, y: %v, z: %v\n", x2, y, z)
```

## 문자열 룬 그리고 바이트

별로 인상적인 구문이 없다.

## 맵

p91 "Go는 셋을 지원하진 않지만 맵을 이용해서 셋처럼 사용할 수 있다" - 왜 굳이 셋을 만들지 않았을까?

## 구조체

p97 "익명 구조체, 두 구조체 변수가 비교 가능하고 이 중 하나는 익명 구조체이면서 두 구조체 같은 이름, 순서, 타입을 가진다면 타입 변환없이 서로 비교가 가능하다. 또한 동일한 상황이라면 이름이 있는 구조체와 익명 구조체간에 할당도 가능하다."

```go
type person struct {
    name string
    age  int
}

var p2 struct {
   name string
   age  int
}

p1 := person {
    name: "gurumee",
    age: 31,
}
p2 = p1
fmt.Println(p1, p2) // {gurumee 31} {gurumee 31}
```
