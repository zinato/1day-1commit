# 10장 Go의 동시성

## 동시성 사용 시점

p278. "동시성은 병렬성이 아니라는 것을 이해하는 것이 중요하다.. 동시성이 도움읻 되는지 확실치 않다면 먼저 코드를 순차적으로 구현하고 동시성 구현과 성능을 비교하기 위해서 벤치마크를 작성하자."

## goroutine

p279. 고루틴의 이점. -> 동시성을 다루는데 적합한 언어 2위 이건 Go의 확실한 이점.

## channel

p283. "채널을 닫아야 하는 책임은 고루틴에 있다. 채널 닫기는 해당 채널이 닫혀지기를 기다리는 고루틴이 있는 경우에만 필요하다."

## select 

p285. "여러 case에 읽거나 쓸 수 있는 경우는 어떻게 될까 select 알고리즘은 단순하다. 진행이 가능한 여러 case 중 하나를 임의로 선택한다. 순서는 중요허지 않다... 모두 동시에 확인되기 때문에 기아 문제를 깔끔하게 해결한다."

## 동시성 사례와 패턴

p288. "동시성은 구현 세부 사항이고 좋은 API 설계는 최대한 구현 세부 사항을 숨겨야 한다. 이는 당신의 코드를 호출 방식 변경 없이 동작 방식을 변경할 수 있도록 한다."

p290. "모든 고루틴을 위한 클로저가 같은 변수를 캡처했기 때문이다. for 루프에서 인덱스와 값은 각 반복에서 재사용되었다." -> 신기방기 IDE 지원으로 어느정도 해결할 수 있다.

p293. "countTo 함수는 두 개의 채널을 생성하는데 하나는 데이터를 반환하고 다른 하나는 종료 시그널을 보낸다." -> 프로메테우스나 로키에서 발견됐었던 기억이..

p294. "버퍼가 있는 채널은 얼마나 많은 고루틴이 실행될 지를 알고 있을 때 실행시킬 고루틴의 개수를 제한하거나 대기중인 작업의 양을 제한하려는 경우에 유용하다. 또한 시스템에서 대기중인 작업의 양을 관리하여 서비스가 뒤쳐지거나 과부하가 걸리는 것을 방지하는데 도움이 된다."

p299. "WaitGroup 사용 사례" -> 깔끔하니 인상적이다.

p300. "WaitGroup은 사용하기 쉬운 반면에, 고루틴을 설계할 때 첫 번째 선택이 되어서는 안된다. 그것은 작업 고루틴이 종료하고 나서 정리할 무엇인가 있는 경우에만 사용하자."

## 채널 대신에 뮤텍스를 사용해야 하는 경우

## atomic 연산

인상적인 구절이 없음. 어차피 쓸 일이 없을 거라 그런가..